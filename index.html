<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Vehicle Dynamics - 6DOF Hardening Spring</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<script src="https://unpkg.com/chart.js@4.4.1/dist/chart.umd.js"></script>

<style>
  body { margin:0; font-family:sans-serif; background:#eaeaea; overflow: hidden; }
  #container { display:flex; height:100vh; width: 100vw; flex-direction: column; }
  #top-section { display: flex; flex: 1; min-height: 0; }
  
  #ui { width:340px; padding:10px; background:#f5f5f5; border-right:1px solid #ccc; overflow-y:auto; flex-shrink: 0; box-shadow: 2px 0 5px rgba(0,0,0,0.1); z-index: 10; height: 100%; box-sizing: border-box;}
  #viewer { flex-grow:1; position:relative; background: #ccc; }
  #chart-container { height: 200px; background: #fff; border-top: 1px solid #999; padding: 10px; flex-shrink: 0; z-index: 20; display: flex; }
  
  h3 { margin:15px 0 5px 0; font-size:12px; border-bottom:1px solid #aaa; padding-bottom: 2px; text-transform: uppercase; letter-spacing: 0.5px; color: #444; }
  .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:6px 10px; }
  label { font-size:11px; display:block; color: #666; }
  input[type="number"], select { width:100%; padding:4px; font-size:11px; border:1px solid #ccc; border-radius: 3px; box-sizing: border-box;}
  .units { float:right; font-size:9px; color:#999; }
  
  button { width:100%; margin-top:5px; padding:8px; font-size:11px; cursor:pointer; background: #e0e0e0; border: 1px solid #bbb; border-radius: 3px; transition: background 0.2s; }
  button:hover { background: #d0d0d0; }
  #solveBtn { background: #d4edda; border-color: #c3e6cb; color: #155724; font-weight: bold; }
  #stopBtn { background: #f8d7da; border-color: #f5c6cb; color: #721c24; font-weight: bold; }
  #addFeatureBtn { background: #d0e8ff; border-color: #b8daff; color: #004085; font-weight: bold; margin-top: 10px;}
  
  #featureList div { background: #fff; padding: 4px; border: 1px solid #ddd; margin-top: 4px; font-size: 11px; display: flex; justify-content: space-between; align-items: center; }
  #timeDisplay { font-size: 12px; font-weight: bold; margin-left: 10px; align-self: center; }
</style>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="container">
  <div id="top-section">
    <div id="ui">
      <div class="auto-update-group">
        <h3>Box 1 (Chassis)</h3>
        <div class="grid2">
          <label>Length (Y) <span class="units">in</span><input id="box1_L" type="number" value="120"></label>
          <label>Width (X)  <span class="units">in</span><input id="box1_W" type="number" value="72"></label>
          <label>Height (Z) <span class="units">in</span><input id="box1_H" type="number" value="24"></label>
          <label>Weight     <span class="units">lb</span><input id="box1_Wt" type="number" value="2500"></label>
        </div>
        <h3>Box 2 (Cab/Cargo)</h3>
        <div class="grid2">
          <label>Length (Y) <span class="units">in</span><input id="box2_L" type="number" value="60"></label>
          <label>Width (X)  <span class="units">in</span><input id="box2_W" type="number" value="60"></label>
          <label>Height (Z) <span class="units">in</span><input id="box2_H" type="number" value="20"></label>
          <label>Weight     <span class="units">lb</span><input id="box2_Wt" type="number" value="800"></label>
          <label>Front Offset (Y) <span class="units">in</span><input id="box2_dY" type="number" value="0"></label>
        </div>
        <h3>Box 3 (Loose Cargo)</h3>
        <div class="grid2">
          <label>Length (Y) <span class="units">in</span><input id="box3_L" type="number" value="20"></label>
          <label>Width (X)  <span class="units">in</span><input id="box3_W" type="number" value="20"></label>
          <label>Height (Z) <span class="units">in</span><input id="box3_H" type="number" value="20"></label>
          <label>Weight     <span class="units">lb</span><input id="box3_Wt" type="number" value="100"></label>
          <label>Initial X <span class="units">in</span><input id="box3_X0" type="number" value="0"></label>
          <label>Initial Y <span class="units">in</span><input id="box3_Y0" type="number" value="-50"></label>
          <label>Friction Coeff<span class="units">µ</span><input id="box3_Fric" type="number" value="0.3" step="0.1"></label>
        </div>
        <h3>Wheels</h3>
        <div class="grid2">
          <label>Diameter <span class="units">in</span><input id="wheel_D" type="number" value="32"></label>
          <label>Weight   <span class="units">lb</span><input id="wheel_Wt" type="number" value="120"></label>
          <label>Front Y  <span class="units">in</span><input id="wheel_Yf" type="number" value="-20"></label>
          <label>Rear Spacing <span class="units">in</span><input id="wheel_dYr" type="number" value="80"></label>
        </div>
      </div>
      <h3>Suspension</h3>
      <div class="grid2">
        <label>Front K <span class="units">lb/in</span><input id="k_sf" type="number" value="300"></label>
        <label>Front C <span class="units">lb·s/in</span><input id="c_sf" type="number" value="25"></label>
        <label>Rear K <span class="units">lb/in</span><input id="k_sr" type="number" value="350"></label>
        <label>Rear C <span class="units">lb·s/in</span><input id="c_sr" type="number" value="30"></label>
      </div>
      <h3>Tires</h3>
      <div class="grid2">
        <label>Front K <span class="units">lb/in</span><input id="k_tf" type="number" value="1200"></label>
        <label>Rear K <span class="units">lb/in</span><input id="k_tr" type="number" value="1400"></label>
        <label>Coeff Friction <span class="units">µ</span><input id="tire_mu" type="number" value="0.1"></label>
      </div>

      <h3>Simulation</h3>
      <div class="grid2">
        <label>Speed <span class="units">in/s</span><input id="veh_v" type="number" value="300"></label>
        <label>Gravity <span class="units">in/s²</span><input id="veh_g" type="number" value="386.1"></label>
        <label>Time Scale <span class="units">x</span><input id="time_scale" type="number" value="1.0" step="0.1" min="0.1" max="10"></label>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <button id="solveBtn">► Solve</button>
        <button id="stopBtn">■ Stop</button>
      </div>
      <button id="updateBtn">Reset / Center Vehicle</button>
      
      <h3>Analysis Point</h3>
      <div class="grid2">
        <label>User X <span class="units">in</span><input id="user_X" type="number" value="0"></label>
        <label>User Y <span class="units">in</span><input id="user_Y" type="number" value="60"></label>
      </div>

      <h3>Road Feature Settings</h3>
      <div class="grid2">
        <label style="grid-column: 1 / span 2;">Type
          <select id="feat_Type">
            <option value="full">Full Speed Bump</option>
            <option value="half_L">1/2 Bump (Left)</option>
            <option value="half_R">1/2 Bump (Right)</option>
            <option value="rough">Rough Dirt Road</option>
          </select>
        </label>
        <label>Height/Roughness <span class="units">in</span><input id="feat_H" type="number" value="3"></label>
        <label>Length Y <span class="units">in</span><input id="feat_W" type="number" value="200"></label>
        <label>Location Y <span class="units">in</span><input id="feat_Y" type="number" value="100"></label>
      </div>
      <button id="addFeatureBtn">+ Add Feature</button>
      <div id="featureList"></div>
    </div>
    <div id="viewer"></div>
  </div>
  <div id="chart-container">
    <canvas id="accelChart"></canvas>
    <div id="timeDisplay">Time: 0.00s</div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let vehicleGroup, groundGroup, looseBox3Mesh;
let roadFeatures = [];
let nextFeatureId = 1;
let simTime = 0;
let massProps = null;
let wheelOffsets = null;
let isRunning = false;
let chartInstance = null;
const maxDataPoints = 200; 
let chartUpdateCounter = 0;
const dt = 1/240; // 240Hz physics

// 6-DOF STATE (X, Y, Z, Phi, Theta, Psi)
const state = {
  x:0, y:0, z:40, phi:0, theta:0, psi:0,
  dx:0, dy:0, dz:0, dphi:0, dtheta:0, dpsi:0,
  zw: { FL:30, FR:30, RL:30, RR:30 },
  dzw: { FL:0, FR:0, RL:0, RR:0 },
  ddz: 0 
};

// HARDENING SPRING ANCHORS
let tireAnchors = { FL:{x:0,y:0}, FR:{x:0,y:0}, RL:{x:0,y:0}, RR:{x:0,y:0} };

const box3State = { x: 0, y: 0, z: 0, dx: 0, dy: 0, dz: 0, az: 0, isOffBed: false };

init();
initChart();
buildVehicle();
setupAutoUpdate();
animate();

function init() {
  const container = document.getElementById('viewer');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xd0d0d0);
  scene.fog = new THREE.Fog(0xd0d0d0, 500, 4000);
  THREE.Object3D.DEFAULT_UP.set(0,0,1);
  camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
  camera.position.set(400, -800, 500);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);
  
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.screenSpacePanning = true; 
  controls.target.set(0, 0, 0); 
  
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(100, -300, 500);
  dirLight.castShadow = true;
  scene.add(dirLight);
  
  groundGroup = new THREE.Group();
  scene.add(groundGroup);
  vehicleGroup = new THREE.Group();
  scene.add(vehicleGroup);
  
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000), new THREE.MeshStandardMaterial({ color: 0xbbbbbb, depthWrite: false }));
  floor.receiveShadow = true;
  groundGroup.add(floor);
  
  const grid = new THREE.GridHelper(10000, 100, 0x999999, 0xcccccc);
  grid.rotation.x = Math.PI/2;
  groundGroup.add(grid);
  
  window.addEventListener('resize', () => {
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
}

function initChart() {
  const ctx = document.getElementById('accelChart').getContext('2d');
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'CG Vert G', borderColor: 'black', pointRadius:0, borderWidth: 2 },
        { label: 'Yaw Rate', borderColor: 'red', pointRadius:0, borderWidth: 2 }
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false, animation: false,
      scales: { x: { display: false }, y: { suggestedMin: -2, suggestedMax: 2 } }
    }
  });
}

function getVal(id) { 
  const el = document.getElementById(id);
  if(!el) return 0;
  if(el.type === 'checkbox') return el.checked;
  return parseFloat(el.value) || 0; 
}
function setVal(id, val) { const el = document.getElementById(id); if(el) el.value = val; }

function setupAutoUpdate() {
  document.querySelectorAll('.auto-update-group input').forEach(input => {
    input.addEventListener('change', () => { if(!isRunning) buildVehicle(true); });
  });
}

document.getElementById('solveBtn').onclick = () => { isRunning = true; };
document.getElementById('stopBtn').onclick = () => { isRunning = false; };
document.getElementById('updateBtn').onclick = () => buildVehicle(false);

function buildVehicle(isAutoUpdate = false) {
  if(!isAutoUpdate) {
    isRunning = false;
    simTime = 0;
    if(chartInstance) {
      chartInstance.data.labels = [];
      chartInstance.data.datasets.forEach(ds => ds.data = []);
      chartInstance.update();
    }
    const tDisp = document.getElementById('timeDisplay');
    if(tDisp) tDisp.innerText = "Time: 0.00s";
  }
  vehicleGroup.clear();
  
  const L1 = getVal('box1_L'), W1 = getVal('box1_W'), H1 = getVal('box1_H');
  const L2 = getVal('box2_L'), W2 = getVal('box2_W'), H2 = getVal('box2_H');
  const L3 = getVal('box3_L'), W3 = getVal('box3_W'), H3 = getVal('box3_H');
  const dY = getVal('box2_dY'); 
  const R  = getVal('wheel_D') / 2;
  const g = getVal('veh_g');
  const m1 = getVal('box1_Wt') / g;
  const m2 = getVal('box2_Wt') / g;
  const M = m1 + m2;
  
  const c1 = { x:0, y: -L1/2, z: H1/2 + R };
  const c2 = { x:0, y: dY - L2/2, z: H1 + H2/2 + R };
  const CG = { x: (m1*c1.x + m2*c2.x)/M, y: (m1*c1.y + m2*c2.y)/M, z: (m1*c1.z + m2*c2.z)/M };
  
  const Ixx = (m1/12)*(W1*W1+H1*H1) + m1*((c1.z-CG.z)**2) + (m2/12)*(W2*W2+H2*H2) + m2*((c2.z-CG.z)**2);
  const Iyy = (m1/12)*(L1*L1+H1*H1) + m1*((c1.z-CG.z)**2) + (m2/12)*(L2*L2+H2*H2) + m2*((c2.z-CG.z)**2);
  const Izz = (m1/12)*(L1*L1+W1*W1) + (m2/12)*(L2*L2+W2*W2);
  massProps = { M, CG, Ixx, Iyy, Izz };
  
  const b1 = new THREE.Mesh(new THREE.BoxGeometry(W1, L1, H1), new THREE.MeshStandardMaterial({color: 0x5577aa}));
  b1.position.set(c1.x - CG.x, c1.y - CG.y, c1.z - CG.z);
  b1.castShadow = true;
  vehicleGroup.add(b1);
  
  const b2 = new THREE.Mesh(new THREE.BoxGeometry(W2, L2, H2), new THREE.MeshStandardMaterial({color: 0x88aabb}));
  b2.position.set(c2.x - CG.x, c2.y - CG.y, c2.z - CG.z);
  b2.castShadow = true;
  vehicleGroup.add(b2);
  
  looseBox3Mesh = new THREE.Mesh(new THREE.BoxGeometry(W3, L3, H3), new THREE.MeshStandardMaterial({color: 0xff4444}));
  looseBox3Mesh.castShadow = true;
  vehicleGroup.add(looseBox3Mesh); 
  
  const wheelGeo = new THREE.CylinderGeometry(R, R, W1*0.2, 24).rotateZ(Math.PI/2);
  const wheelMat = new THREE.MeshStandardMaterial({color: 0x222222});
  const yF = getVal('wheel_Yf'), yR = yF - getVal('wheel_dYr');
  const xW = W1/2; 
  const wheels = [ {n:'FL', x:-xW, y:yF}, {n:'FR', x:xW, y:yF}, {n:'RL', x:-xW, y:yR}, {n:'RR', x:xW, y:yR} ];
  
  wheelOffsets = wheels.map(w => ({ name: w.n, x: w.x - CG.x, y: w.y - CG.y }));
  wheels.forEach(w => {
    const mesh = new THREE.Mesh(wheelGeo, wheelMat);
    mesh.name = "W_" + w.n;
    mesh.position.set(w.x - CG.x, w.y - CG.y, R - CG.z); 
    mesh.castShadow = true;
    vehicleGroup.add(mesh);
  });
  
  if(!isAutoUpdate || simTime === 0) {
    // 6-DOF Reset
    state.x=0; state.y=0; state.z=CG.z+5;
    state.phi=0; state.theta=0; state.psi=0;
    state.dx=0; state.dy=getVal('veh_v'); state.dz=0;
    state.dphi=0; state.dtheta=0; state.dpsi=0;
    state.zw.FL=CG.z; state.zw.FR=CG.z; state.zw.RL=CG.z; state.zw.RR=CG.z; // Approx
    
    // CRITICAL FIX: Init Anchors to match Wheel Pos exactly at t=0
    // Wheel Pos (World) = Car(0,0) + Offset
    wheelOffsets.forEach(w => {
        tireAnchors[w.name] = { x: w.x, y: w.y };
    });

    const bedHeight = (c1.z - CG.z) + H1/2;
    box3State.x = getVal('box3_X0'); box3State.y = getVal('box3_Y0');
    box3State.z = bedHeight + H3/2 + 2; 
    box3State.dx=0; box3State.dy=0; box3State.dz=0;
    
    controls.target.set(0,0,0); controls.update();
  }
}

function getRoadZ(x, y) {
  let z = 0;
  for(let f of roadFeatures) {
    if(f.type === 'rough') {
      if (y >= (f.params.y - f.params.w/2) && y <= (f.params.y + f.params.w/2)) {
        z = f.params.h * (0.5*Math.sin(0.1*y)*Math.sin(0.1*x) + 0.3*Math.sin(0.3*y+1.2));
      }
      continue;
    }
    const dy = y - f.params.y;
    const r = f.params.w/2;
    if(Math.abs(dy) < r) {
      if(f.type==='half-bump' && ((f.params.side==='left' && x>0) || (f.params.side==='right' && x<0))) continue;
      z = Math.max(z, f.params.h * Math.sqrt(1 - (dy*dy)/(r*r)));
    }
  }
  return z;
}

function addFeatureMesh(geom, color, x, y) {
  const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color}));
  mesh.position.set(x, y, 0); mesh.receiveShadow = true;
  groundGroup.add(mesh);
  return mesh;
}

document.getElementById('addFeatureBtn').onclick = () => {
  const type = document.getElementById('feat_Type').value;
  const h = getVal('feat_H'), w = getVal('feat_W'), y = getVal('feat_Y');
  if (type === 'full') addSpeedBump(h, w, y);
  else if (type === 'half_L') addHalfSpeedBump(h, w, y, 'left');
  else if (type === 'half_R') addHalfSpeedBump(h, w, y, 'right');
  else if (type === 'rough') addRoughPatch(h, w, y);
  setVal('feat_Y', y + (type==='rough' ? w + 50 : 100));
};

function addSpeedBump(h, w, y) {
  const W = getVal('box1_W')*3; 
  const geom = new THREE.ExtrudeGeometry(new THREE.Shape().moveTo(-w/2,0).absarc(0,0,w/2,0,Math.PI,false).lineTo(w/2,0), {depth:W, bevelEnabled:false});
  geom.translate(0, 0, -W/2); geom.rotateX(Math.PI/2); geom.rotateZ(Math.PI/2);
  const mesh = addFeatureMesh(geom, 0x888888, 0, y);
  roadFeatures.push({id: nextFeatureId++, type:'bump', params:{h,w,y}, mesh});
  refreshFeatures();
}
function addHalfSpeedBump(h, w, y, side) {
  const carW = getVal('box1_W');
  const geom = new THREE.ExtrudeGeometry(new THREE.Shape().moveTo(-w/2,0).absarc(0,0,w/2,0,Math.PI,false).lineTo(w/2,0), {depth:carW*0.4, bevelEnabled:false});
  geom.translate(0, 0, -carW*0.2); geom.rotateX(Math.PI/2); geom.rotateZ(Math.PI/2);
  const xOff = (side==='left' ? -carW/2 : carW/2);
  const mesh = addFeatureMesh(geom, 0x777777, xOff, y);
  roadFeatures.push({id: nextFeatureId++, type:'half-bump', params:{h,w,y,side}, mesh});
  refreshFeatures();
}
function addRoughPatch(h, w, y) {
  const carW = getVal('box1_W');
  const geom = new THREE.PlaneGeometry(carW*3, w, 20, Math.max(5, Math.floor(w/10)));
  const pos = geom.attributes.position;
  for(let i=0; i<pos.count; i++) pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*2.0);
  geom.computeVertexNormals();
  const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color: 0x8B4513, roughness: 1.0}));
  mesh.position.set(0, y, 0.5);
  groundGroup.add(mesh);
  roadFeatures.push({id: nextFeatureId++, type:'rough', params:{h,w,y}, mesh});
  refreshFeatures();
}
function refreshFeatures() {
  document.getElementById('featureList').innerHTML = roadFeatures.map((f,i) => {
    let desc = f.type;
    if(f.type==='half-bump') desc = f.params.side==='left' ? '½L' : '½R';
    return `<div><span><b>${desc}</b> @${f.params.y.toFixed(0)}</span><button onclick="window.delFeat(${i})">x</button></div>`;
  }).join('');
}
window.delFeat = (i) => { groundGroup.remove(roadFeatures[i].mesh); roadFeatures.splice(i,1); refreshFeatures(); };

function stepBox3(dt, vehAccel) {
  if(!massProps) return;
  if(!box3State.isOffBed) {
    box3State.x = getVal('box3_X0'); box3State.y = getVal('box3_Y0');
    const bedZ = (getVal('box1_H')/2 + getVal('wheel_D')/2) - massProps.CG.z + getVal('box1_H')/2;
    box3State.z = bedZ + getVal('box3_H')/2;
    box3State.az = vehAccel.ddz;
  }
}

// 6-DOF DERIVATIVES + HARDENING SPRING LATERAL
function getDerivatives(t, s) {
  if(!massProps || !wheelOffsets) return Array(20).fill(0);
  const x=s[0], y=s[1], z=s[2], phi=s[3], theta=s[4], psi=s[5];
  const dx=s[6], dy=s[7], dz=s[8], dphi=s[9], dtheta=s[10], dpsi=s[11];
  
  const g = getVal('veh_g');
  const wm = getVal('wheel_Wt')/g;
  const cP = Math.cos(psi), sP = Math.sin(psi);
  
  let Fx_tot=0, Fy_tot=0, Fz_tot=0, Mx_tot=0, My_tot=0, Mz_tot=0;
  const ddzw = [0,0,0,0];
  const R = getVal('wheel_D')/2;
  const tireK = 500; // Lateral Stiffness
  const tireC = 20;  // Lateral Damping
  
  // Aero Damping
  Fx_tot -= 0.02 * dx; Fy_tot -= 0.02 * dy; Mz_tot -= 100 * dpsi;

  ['FL','FR','RL','RR'].forEach((n, i) => {
    const wOff = wheelOffsets[i];
    // Wheel Pos World
    const wx = x + cP*wOff.x - sP*wOff.y;
    const wy = y + sP*wOff.x + cP*wOff.y;
    
    // Vertical Susp
    const zw = s[12+i];
    const zb = z - phi*wOff.x + theta*wOff.y;
    const dzb = dz - dphi*wOff.x + dtheta*wOff.y;
    const k_s = n.startsWith('F') ? getVal('k_sf') : getVal('k_sr');
    const c_s = n.startsWith('F') ? getVal('c_sf') : getVal('c_sr');
    const F_susp = Math.max(0, k_s*(25-(zb-zw)) + c_s*(s[16+i]-dzb)); // Flip relative velocity sign
    
    Fz_tot += F_susp;
    Mx_tot -= F_susp * wOff.x; 
    My_tot += F_susp * wOff.y;
    
    const roadZ = getRoadZ(wx, wy);
    const pen = roadZ - (zw - R);
    const k_t = n.startsWith('F') ? getVal('k_tf') : getVal('k_tr');
    const F_tire_z = (pen>0) ? k_t*pen : 0;
    ddzw[i] = (F_tire_z - F_susp - wm*g) / wm;
    
    // LATERAL HARDENING SPRING
    if(F_tire_z > 0) {
        const anchor = tireAnchors[n];
        const stretchX = wx - anchor.x;
        const stretchY = wy - anchor.y;
        
        // Lateral Axis is (cP, sP) = Right vector
        const latStretch = stretchX*cP + stretchY*sP;
        
        // Lateral Velocity for damping
        const vx_w = dx - dpsi*(sP*wOff.x + cP*wOff.y);
        const vy_w = dy + dpsi*(cP*wOff.x - sP*wOff.y);
        const v_lat = vx_w*cP + vy_w*sP;
        
        let F_lat = -tireK * latStretch - tireC * v_lat;
        
        // Friction Limit
        const limit = getVal('tire_mu') * F_tire_z;
        if(Math.abs(F_lat) > limit) {
            F_lat = Math.sign(F_lat) * limit;
            // Move Anchor
            const allowed = limit / tireK; // Ignore damping for displacement limit
            const correction = Math.abs(latStretch) - allowed;
            const sign = Math.sign(latStretch);
            if(correction > 0) {
                tireAnchors[n].x += sign * correction * cP;
                tireAnchors[n].y += sign * correction * sP;
            }
        }
        
        // Apply Force
        Fx_tot += F_lat * cP; // Wait.. Side force along Right Vector(cP, sP)? No.
        // If F_lat is positive (Left), it pushes towards -Right Vector?
        // My sign convention: F = -k*x. 
        // If x is positive (wheel right of anchor), F is negative (push left).
        // So F acts along lateral axis.
        // Lateral Axis Vector = (cP, sP).
        
        // Wait. F_lat is magnitude. Direction is along Lateral Axis.
        Fx_tot += F_lat * cP; 
        Fy_tot += F_lat * sP;
        
        // Torque Mz = r x F
        // r = wOff (local). F = (F_lat, 0) local?
        // Standard: X fwd, Y left. 
        // Here: X lateral (width), Y longitudinal.
        // Force is in X. Arm is Y.
        // Torque = -Y * Fx
        Mz_tot -= wOff.y * F_lat;
    } else {
        tireAnchors[n] = {x: wx, y: wy};
    }
  });
  
  const ddx = Fx_tot / massProps.M;
  const ddy = Fy_tot / massProps.M;
  const ddz = (Fz_tot - massProps.M*g) / massProps.M;
  const ddphi = My_tot / massProps.Ixx;
  const ddtheta = Mx_tot / massProps.Iyy;
  const ddpsi = Mz_tot / massProps.Izz;
  
  return [ dx,dy,dz,dphi,ddtheta,dpsi, ddx,ddy,ddz,ddphi,ddtheta,ddpsi, 
           s[16],s[17],s[18],s[19], ddzw[0],ddzw[1],ddzw[2],ddzw[3] ];
}

function packState(s) {
  return [ s.x,s.y,s.z,s.phi,s.theta,s.psi, s.dx,s.dy,s.dz,s.dphi,s.dtheta,s.dpsi,
           s.zw.FL,s.zw.FR,s.zw.RL,s.zw.RR, s.dzw.FL,s.dzw.FR,s.dzw.RL,s.dzw.RR ];
}

function stepRK4(dt) {
  const s = packState(state);
  const t = simTime;
  const k1 = getDerivatives(t, s);
  const s2 = s.map((v,i) => v + k1[i]*dt*0.5);
  const k2 = getDerivatives(t+dt*0.5, s2);
  const s3 = s.map((v,i) => v + k2[i]*dt*0.5);
  const k3 = getDerivatives(t+dt*0.5, s3);
  const s4 = s.map((v,i) => v + k3[i]*dt);
  const k4 = getDerivatives(t+dt, s4);
  const fin = s.map((v,i) => v + (dt/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
  
  state.x=fin[0]; state.y=fin[1]; state.z=fin[2];
  state.phi=fin[3]; state.theta=fin[4]; state.psi=fin[5];
  state.dx=fin[6]; state.dy=fin[7]; state.dz=fin[8];
  state.dphi=fin[9]; state.dtheta=fin[10]; state.dpsi=fin[11];
  
  state.zw.FL=fin[12]; state.zw.FR=fin[13]; state.zw.RL=fin[14]; state.zw.RR=fin[15];
  state.dzw.FL=fin[16]; state.dzw.FR=fin[17]; state.dzw.RL=fin[18]; state.dzw.RR=fin[19];
  
  const vehAccel = { ddz: k1[8], ddphi: k1[9], ddtheta: k1[10] };
  stepBox3(dt, vehAccel);
  state.ddz = vehAccel.ddz; 
  simTime += dt;
}

function updateChart() {
  chartUpdateCounter++; if(chartUpdateCounter < 5) return; chartUpdateCounter=0;
  document.getElementById('timeDisplay').innerText = `Time: ${simTime.toFixed(2)}s`;
  const g = getVal('veh_g'); 
  chartInstance.data.labels.push(simTime.toFixed(2));
  chartInstance.data.datasets[0].data.push(state.ddz / g);
  chartInstance.data.datasets[1].data.push(state.dpsi); // Yaw Rate
  if(chartInstance.data.labels.length > maxDataPoints) {
    chartInstance.data.labels.shift(); chartInstance.data.datasets.forEach(ds => ds.data.shift());
  }
  chartInstance.update();
}

function animate() {
  requestAnimationFrame(animate);
  if(isRunning && massProps) {
    const ts = getVal('time_scale');
    stepRK4(dt * ts);
    updateChart();
    // Camera follows car smoothly
    controls.target.set(state.x, state.y, state.z);
  }
  
  controls.update(); 
  
  vehicleGroup.position.set(state.x, state.y, state.z);
  vehicleGroup.rotation.set(state.theta, state.phi, state.psi);
  
  // Move ground with car visually
  groundGroup.position.x = Math.floor(state.x/200)*200;
  groundGroup.position.y = Math.floor(state.y/200)*200;
  
  if(wheelOffsets) {
    ['FL','FR','RL','RR'].forEach(n => {
      const mesh = vehicleGroup.getObjectByName("W_"+n);
      if(mesh) mesh.position.z = state.zw[n] - state.z;
    });
  }
  
  looseBox3Mesh.position.set(box3State.x, box3State.y, box3State.z);
  renderer.render(scene, camera);
}
</script>
</body>
</html>
